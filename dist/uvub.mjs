function N(t){if(t==null||typeof t!="object")return!0;for(const n in t)return!1;return!0}function G(t,n){const e={__test__:"",__suite__:t};return n===void 0||N(n)?e:Object.assign(n,e)}function x(t){return{tests:[],before:[],after:[],bEach:[],aEach:[],only:[],skipped:0,state:t}}function I(t,n){return function(e){const{only:u,tests:w,before:d,after:b,bEach:y,aEach:s,state:f}=t,p=u.length?u:w,l=[];let i,c=0;const g=async()=>{try{for(const r of b)await r(f)}finally{const r=t.skipped+(u.length?w.length:0),a=p.length;e.suiteResult(l,a,c,r),i=[c,r,a,l.length>0]}};let E=async()=>{try{e.suiteStart(n);for(const r of d)await r(f)}catch(r){try{g()}catch{throw r}throw r}finally{E=void 0}},o=0;return async function(){if(i)return i;E&&await E();const[r,a]=p[o];f.__test__=r;try{for(const h of y)await h(f);await a(f);for(const h of s)await h(f);e.testPass(),c+=1}catch(h){for(const k of s)await k(f);l.push([h,r,n]),e.testFail()}return f.__test__="",o+=1,o>=p.length&&await g(),i===void 0?!0:i}}}const m=new Map;function X(t,n){let e=m.get(n);e===void 0&&(e=[],m.set(n,e)),e.push(t)}let _,j;function q(t,n){X(t,n),!(j==null||_!==void 0)&&(clearTimeout(_),_=setTimeout(j))}function O(t,n){return function(e){t[n].push(e)}}function T(t,n,e){return Object.assign(O(t,n),{each:O(t,e)})}function M(t,n){return function(e,u){t[n].push([e,u])}}function z(t,n){const e=M(t,"tests"),u=M(t,"only"),w=T(t,"before","bEach"),d=T(t,"after","aEach");return Object.assign(e,{before:w,after:d,only:u,skip:()=>{t.skipped+=1},run:()=>{const b={...t},y=I(b,n);Object.assign(t,x(b.state)),q(y,n)}})}function P(t="",n){return z(x(G(t,n)),t)}let v;function H(t){const n=t||v;if(!(n!=null&&n.reporter))throw new Error("uvb.exec: Missing configuration (reporter)");return n}function R(t){let n=performance.now(),e=0;const u=()=>{const o=performance.now();return e+=o-n,n=o,e},{reporter:w,interval:d,bail:b=!1}=H(t),y=d&&d>=10?d:Number.MAX_SAFE_INTEGER,s={withErrors:!1,done:0,skipped:0,total:0,duration:0};let f=!1;const p=o=>(s.withErrors=o??s.withErrors,s.duration=u(),w.result(s),_=void 0,f=!0,s.withErrors),l=[...m.values()];let i=-1,c=-1;t:for(let o=0;o<l.length;o+=1){if(l[o].length<1)continue;const r=l[o];for(let a=0;a<r.length;a+=1)if(typeof r[a]=="function"){i=o,c=a;break t}}if(i<0||c<0)return Promise.resolve(p());let g=l[i],E=g[c](w);return new Promise((o,r)=>{async function a(){f&&r(new Error("continueExec() invoked after teardown!"));try{for(n=performance.now();;){for(;;){const h=await E();if(h!==!0){const[k,S,A,F]=h;if(s.total+=A,s.done+=k,s.skipped+=S,s.withErrors||(s.withErrors=F),s.withErrors&&b&&o(p()),c+=1,c>=g.length)break;E=g[c](w)}if(!(performance.now()-n<y)){u(),setTimeout(a);return}}if(i+=1,i>=l.length)break;g=l[i],c=0,E=g[c](w)}}catch(h){p(!0),r(h)}o(p())}u(),a()})}function Q(t){v=t,j=v?.autorun===!0?()=>R(t):void 0}const U=P();export{Q as configure,R as exec,P as suite,U as test};
